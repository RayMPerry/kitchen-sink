-- RE: error: subtype 'niltype' is not addressable thus cannot have a pointer

-- As of 5/2/23, the nil type is not addressable and as a
-- result, this implementation is coded in a fashion that expects
-- every non-nil value to be Some and nil is None. This will change if
-- the nil type becomes addressable in a future release.

## local make_Option = generalize(function (T)
  local T = #[T]#

  local OptionT = @record {
     raw_value: T,
     value: *T
  }

  function OptionT:is_some(): boolean
     return self.value ~= nilptr
  end

  function OptionT:is_none(): boolean
     return not self:is_some()
  end
  
  function OptionT:some(): T
     if self:is_none() then error('attempt to call some() on None') end
     return $self.value
  end
  
  function OptionT:none(): niltype
     if self:is_some() then error('attempt to call none() on Some') end
     return nil
  end

  function OptionT:set(new_value: T)
     self.raw_value = new_value
     self.value = &self.raw_value
  end

  -- DEV: This is going to assume None() == option(integer)
  function OptionT:unset()
     self.raw_value = 0
     self.value = nilptr
  end
  
  ## return OptionT
## end)

global option: type = #[make_Option]#

global function Some(value: auto)
   local T = #[value.type]#
   assert(T ~= niltype, 'attempt to create Some() from nil')
   local option: option(T)
   option:set(value)
   return option
end

-- DEV: option(integer) is a hack until niltype is addressable 
global function None(): option(integer)
   local option: option(integer)
   option:unset()
   return option
end
